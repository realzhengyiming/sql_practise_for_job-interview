# 最* 的类型题目

（1）**查出每个用户第一单的消费金额**。链接：https://www.nowcoder.com/questionTerminal/b61f123aeaad48dd8afa1937f528e5e6
来源：牛客网



用户分析是电商数据分析中重要的模块，在对用户特征深度理解和用户需求充分挖掘基础上，进行全生命周期的运营管理（拉新—>活跃—>留存—>价值提升—>忠诚），请尝试回答以下3个问题： 

  ① 用户第一单购买的行为往往反映了用户对平台的信任度和消费能力。现在数据库中有一张用户交易表order，其中有userid（用户ID）、amount（消费金额）、paytime（支付时间），请写出对应的SQL语句，**查出每个用户第一单的消费金额**。

② 当你发现本月的支付用户数环比上月大幅下跌（超30%），你会如何去探查背后的原因？请描述你的思路和其中涉及的关键指标 

  ③ 为了更好的理解用户，我们通常会基于用户的特征对用户进行分类，便于更加精细化的理解用户，设计产品和运营玩法，请你设计对应的聚类方法，包括重点的用户特征的选择及聚类算法并说明其基本原理和步骤



`select userid,amount from (select userid,amount,min(paytime) group  by userid )`



```
select a.* from
order a join (
  ``select userid, min(paytime) min_time
  ``from order group by userid
  ``) b
on a.userid = b.userid
and a.paytime = b.min_time;
```

<br>

(2)[176. 第二高的薪水](https://leetcode-cn.com/problems/second-highest-salary/)

编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。

```
select ifnull(select max(Salary) SecondHighestSalary
from employee
where
salary<(select max(salary) from employee),null) as SecondHighestSalary   
# 小于最大的，剩下的最大的就是第二大的，嵌套 ,外层再加一个判断，如果是空的化返回一个null
```

或者分页<br>

```mysql
select IFNULL((select distinct(Salary) 
from Employee
order by Salary desc
limit 1,1),null) as SecondHighestSalary
```



#### （3）[177. 第N高的薪水](https://leetcode-cn.com/problems/nth-highest-salary/)

这下有思路了，分页是个不错的操作啊，

SQl也是可以写函数的，写好后怎么用呢？我查查

```mysql/sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
    set N = N-1;  # 声明一个东西用set，赋值用 :=   海象算子？
    IF N<0 THEN
    RETURN NULL;
    ELSE
    RETURN (
        # Write your MySQL query statement below.
        ###########
        select ifnull(
            (select Salary from Employee group by Salary order by Salary limit N,1) 
        ,null) as getNthHighestSalary
        ###########
    );
    END IF;
END

# 先执行这个，后调用函数，往后再单独调用，
select getNthHighestSalary(4)    # 这样调用就可以

# 分页是limit n,1   (第一个n是从第n个顺序开始，然后往后去1个的意思，注意sql的也是从下标0开始)

# 删除自定义函数
DROP FUNCTION [IF EXISTS] function_name
```

#### [178. 分数排名](https://leetcode-cn.com/problems/rank-scores/)

排序相关，这个csdn的帖子也讲得很好的了。https://blog.csdn.net/weixin_42228338/article/details/83417411<br>

编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。<font color=red><b>(也就是说这是连续排名)</b></font>

种类：

+ 连续的排名不空缺（1，2，3，4）下面的解法，或者mysql8.0
  + 可以使用窗口函（需要版本支持）
  + **其中需要注意的是：over（partition by class order by property） 按照property排序进行累计，order by是个默认的开窗函数，按照class分区。这里面是按照class来进行不同类别的排序的**
    + 序号函数：row_number()  over(patition by something order by other......)，**相同的值里面排序，多个同为100的值排1，2，3（按一定的顺序排）**
    + rank()  over(patition by something order by other......)  这个是**跳跃排序，相同的排1，1，然后下一个就是3**
    + dense_rank() over(patition by something order by other......) 这种是**连续的排序，1，1，1，1，2，2，3，3，3这样，适合这种。**不跳跃1，2，3名
  + 不使用窗口函数
    + 如下是其中的一种思路
+ 不连续的排名（1，1，3）这种
  + 

mysql中变量不用事前申明，在用的时候直接用“@变量名”使用就可以了。
第一种用法：set @num=1; 或set @num:=1; //这里要使用变量来保存数据，直接使用@num变量
第二种用法：select @num:=1; 或 select @num:=字段名 from 表名 where ……
注意上面两种赋值符号，使用set时可以用“=”或“：=”，但是使用select时必须用“：=赋值”

第三种用法：select 字段名1,字段名2 into @变量1,@变量2 from 表名 where ......

在函数或存储过程或触发器中，在不能使用set的时候推荐第三种，因为第二种会在执行时返回查询结果，这在函数或触发器中会报 “Not allowed to return a result set from a function”错误。而第三种则不会报错

### 不使用窗口函数，连续的排名，相同分数排名相同(自我连接self join)

常规使用声明中间变量来处理的情况mysql8.0以下：

https://www.bbsmax.com/A/l1dyPRr05e/

```python
set @rank = 0;
set @prescore = 0;

SELECT *,case 
	when @prescore=score then @rank
	when @prescore:=score then @rank:=@rank+1   # 第二个的时候这种算when是算没有判断条件的，赋值结束直接进入第二个then
	end as RANK
FROM `test` order by score desc
```

或者

```python
SET @rank=0;
 
SET @PREScore=0;
 
SELECT Score,RANk,sss FROM(
 
SELECT Score,IF(@PREScore=Score,@rank,@rank:=@rank+1) AS RANK,
 
@PREScore:=Score  as  sss
 
FROM test
ORDER BY Score DESC)S;  
```



再或者使用这种取巧的方法，比前面有多少个比自己大的。

````
select s1.score,(select count(*)+1 from 
  			(select distinct score from Scores) s2 where s2.score>s1.score) as Rank 
from Scores s1 order by Rank  
#上面这个和下下面这个是等价的，这个就是自连的例子
# 如果需要只看独立的还可以group by Rank 加上
# 这种叫做相关子查询，所以先执行外层的那个别名
SELECT id2 ,(select count(distinct only.id2)+1 from hello only  where a.id2>only.id2) as rank FROM `Scores` as a order by rank 


select score as "Score" , dense_rank() over (order by score desc) as "Rank" from Scores
# 这种需要mysql8.0 才支持窗口函数
````



不连续的,跳跃的排位则需要中间变量来存储一下排位值。1，1，1，4这样前面会占用排名

```mysql 8.0以下
SELECT pid, name, age, rank FROM
(SELECT pid, name, age,
@curRank := IF(@prevRank = age, @curRank, @incRank) AS rank, 
@incRank := @incRank + 1,      # 通过这几个中间变量的变化加减来进行判断。
@prevRank := age
FROM players p, (
SELECT @curRank :=0, @prevRank := NULL, @incRank := 1
) r 
ORDER BY age) s
```



#### [180. 连续出现的数字](https://leetcode-cn.com/problems/consecutive-numbers/)

这个厉害，这个就是查看用户最大连续登陆天数类似的，按一定的排列顺序，然后找到他的最大的连续登陆次数吗（连续出现的姓名，按照日期看日志，还是有一些不同的）





  (select count(*)+1 

​    from (select distinct score from Scores) s2 

​        where s2.score>s1.score) as Rank 

​      from Scores s1 order by Rank